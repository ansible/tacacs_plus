# Copyright (c) 2017 Ansible by Red Hat
# All Rights Reserved.

import argparse
import contextlib
import getpass
import logging
import random
import select
import socket
import struct
import sys
from hashlib import md5

import six

logger = logging.getLogger(__file__)

# versioning
TAC_PLUS_MAJOR_VER = 0xc
TAC_PLUS_MINOR_VER = 0x0
TAC_PLUS_MINOR_VER_ONE = 0x1

# types + actions
TAC_PLUS_AUTHEN = 0x01
TAC_PLUS_AUTHOR = 0x02
TAC_PLUS_AUTHEN_LOGIN = 0x01

# services
TAC_PLUS_AUTHEN_SVC_NONE = 0x00
TAC_PLUS_AUTHEN_SVC_LOGIN = 0x01

# authentication types
TAC_PLUS_AUTHEN_TYPE_NOT_SET = 0x00
TAC_PLUS_AUTHEN_TYPE_ASCII = 0x01
TAC_PLUS_AUTHEN_TYPE_PAP = 0x02
TAC_PLUS_AUTHEN_TYPE_CHAP = 0x03
TAC_PLUS_AUTHEN_TYPES = {
    'ascii': TAC_PLUS_AUTHEN_TYPE_ASCII,
    'pap': TAC_PLUS_AUTHEN_TYPE_PAP,
    'chap': TAC_PLUS_AUTHEN_TYPE_CHAP,
}

# authentication statuses
TAC_PLUS_AUTHEN_STATUS_PASS = 0x01
TAC_PLUS_AUTHEN_STATUS_FAIL = 0x02
TAC_PLUS_AUTHEN_STATUS_GETPASS = 0x05
TAC_PLUS_AUTHEN_STATUS_ERROR = 0x07

# priveleges
TAC_PLUS_PRIV_LVL_MIN = 0x00
TAC_PLUS_PRIV_LVL_MAX = 0x0F

# authorization statuses
TAC_PLUS_AUTHOR_STATUS_PASS_ADD = 0x01
TAC_PLUS_AUTHOR_STATUS_PASS_REPL = 0x02
TAC_PLUS_AUTHOR_STATUS_FAIL = 0x10
TAC_PLUS_AUTHOR_STATUS_ERROR = 0x11
TAC_PLUS_AUTHOR_STATUS_FOLLOW = 0x21

# authentication methods
TAC_PLUS_AUTHEN_METH_NOT_SET = 0x00
TAC_PLUS_AUTHEN_METH_NONE = 0x01
TAC_PLUS_AUTHEN_METH_KRB5 = 0x02
TAC_PLUS_AUTHEN_METH_LINE = 0x03
TAC_PLUS_AUTHEN_METH_ENABLE = 0x04
TAC_PLUS_AUTHEN_METH_LOCAL = 0x05
TAC_PLUS_AUTHEN_METH_TACACSPLUS = 0x06
TAC_PLUS_AUTHEN_METH_GUEST = 0x08
TAC_PLUS_AUTHEN_METH_RADIUS = 0x10
TAC_PLUS_AUTHEN_METH_KRB4 = 0x11
TAC_PLUS_AUTHEN_METH_RCMD = 0x20


def crypt(header, body_bytes, secret):
    """
    TACACS+ uses a shared secret key (known to both the client and server)
    to obfuscate the body of sent packets.  Only the packet body (not
    the header) is obfuscated.

    https://datatracker.ietf.org/doc/draft-ietf-opsawg-tacacs/?include_text=1#section-3.7

    ENCRYPTED {data} == data ^ pseudo_pad

    The pad is generated by concatenating a series of MD5 hashes (each 16
    bytes long) and truncating it to the length of the input data.

    pseudo_pad = {MD5_1 [,MD5_2 [ ... ,MD5_n]]} truncated to len(data)

    The first MD5 hash is generated by concatenating the session_id, the
    secret key, the version number and the sequence number and then
    running MD5 over that stream.  All of those input values are
    available in the packet header, except for the secret key which is a
    shared secret between the TACACS+ client and server.

    Subsequent hashes are generated by using the same input stream, but
    concatenating the previous hash value at the end of the input stream.

    MD5_1 = MD5{session_id, key, version, seq_no} MD5_2 = MD5{session_id,
    key, version, seq_no, MD5_1} ....  MD5_n = MD5{session_id, key,
    version, seq_no, MD5_n-1}

    :param header:     a TACACSHeader object
    :param body_bytes: packed bytes, i.e., `struct.pack(...)
    :param secret:     a key used to encrypt/obfuscate packets according
                       to the TACACS+ spec

    :return:           packed bytes, i.e., `struct.pack(...) representing the
                       obfuscated packet body
    """  # noqa

    # B = unsigned char
    # !I = network-order (big-endian) unsigned int
    body_length = len(body_bytes)
    unhashed = (
        struct.pack('!I', header.session_id) +
        six.b(secret) +
        struct.pack('B', header.version) +
        struct.pack('B', header.seq_no)
    )
    pad = hashed = md5(unhashed).digest()

    if (len(pad) < body_length):
        # remake hash, appending it to pad until pad >= header.length
        while True:
            hashed = md5(unhashed + hashed).digest()
            pad += hashed
            if len(pad) >= body_length:
                break

    pad = pad[0:(body_length)]
    pad = list(struct.unpack('B' * len(pad), pad))

    packet_body = []
    for x in struct.unpack('B' * body_length, body_bytes):
        packet_body.append(x ^ pad.pop(0))

    return struct.pack('B' * len(packet_body), *packet_body)


class TACACSPacket(object):

    def __init__(self, header, body_bytes, secret):
        """
        :param header:     a TACACSHeader object
        :param body_bytes: packed bytes, i.e., `struct.pack(...)
        :param secret:     a key used to encrypt/obfuscate packets according
                           to the TACACS+ spec
        """
        self.header = header
        self.body_bytes = body_bytes
        self.secret = secret

    @property
    def encrypted(self):
        return self.secret is not None

    @property
    def seq_no(self):
        return self.header.seq_no

    @property
    def body(self):
        if self.encrypted:
            return self.crypt
        return self.body_bytes

    def __str__(self):
        return self.header.packed + self.body

    def __bytes__(self):
        return self.header.packed + self.body

    @property
    def crypt(self):
        return crypt(self.header, self.body_bytes, self.secret)


class TACACSHeader(object):

    def __init__(self, version, type, session_id, length, seq_no=1, flags=0):
        self.version = version
        self.type = type
        self.session_id = session_id
        self.length = length
        self.seq_no = seq_no
        self.flags = flags

    @property
    def version_max(self):
        return self.version // 0x10

    @property
    def version_min(self):
        return self.version % 0x10

    @property
    def packed(self):
        # All TACACS+ packets always begin with the following 12 byte header.
        # The header is always cleartext and describes the remainder of the
        # packet:
        # 1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8
        #
        # +----------------+----------------+----------------+----------------+
        # |major  | minor  |                |                |                |
        # |version| version|      type      |     seq_no     |   flags        |
        # +----------------+----------------+----------------+----------------+
        # |                            session_id                             |
        # +----------------+----------------+----------------+----------------+
        # |                              length                               |
        # +----------------+----------------+----------------+----------------+

        # B = unsigned char
        # !I = network-order (big-endian) unsigned int
        return struct.pack(
            'BBBB',
            self.version,
            self.type,
            self.seq_no,
            self.flags
        ) + struct.pack('!I', self.session_id) + struct.pack('!I', self.length)

    @classmethod
    def unpacked(cls, raw):
        # B = unsigned char
        # !I = network-order (big-endian) unsigned int
        raw = six.BytesIO(raw)
        version, type, seq_no, flags = struct.unpack(
            'BBBB',
            raw.read(4)
        )
        session_id, length = struct.unpack('!II', raw.read(8))
        return cls(version, type, session_id, length, seq_no, flags)

    def __str__(self):
        return ', '.join([
            'version: %s' % self.version,
            'type: %s' % self.type,
            'session_id: %s' % self.session_id,
            'length: %s' % self.length,
            'seq_no: %s' % self.seq_no,
            'flags: %s' % self.flags,
        ])


class TACACSAuthenticationStart(object):

    def __init__(self, username, authen_type, priv_lvl=TAC_PLUS_PRIV_LVL_MIN,
                 data=six.b('')):
        self.username = username
        self.action = TAC_PLUS_AUTHEN_LOGIN
        self.priv_lvl = priv_lvl
        self.authen_type = authen_type
        self.service = TAC_PLUS_AUTHEN_SVC_LOGIN
        self.data = data

    @property
    def packed(self):
        # 1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8
        #
        # +----------------+----------------+----------------+----------------+
        # |    action      |    priv_lvl    |  authen_type   |     service    |
        # +----------------+----------------+----------------+----------------+
        # |    user len    |    port len    |  rem_addr len  |    data len    |
        # +----------------+----------------+----------------+----------------+
        # |    user ...
        # +----------------+----------------+----------------+----------------+
        # |    port ...
        # +----------------+----------------+----------------+----------------+
        # |    rem_addr ...
        # +----------------+----------------+----------------+----------------+
        # |    data...
        # +----------------+----------------+----------------+----------------+

        # B = unsigned char
        # s = char[]
        username = six.b(self.username)
        data = self.data
        port = rem_addr = six.b('')
        body = struct.pack(
            'B' * 8,
            self.action,
            self.priv_lvl,
            self.authen_type,
            self.service,
            len(username),
            len(port),
            len(rem_addr),
            len(data),
        )
        for value in (username, port, rem_addr, data):
            body += struct.pack('%ds' % len(value), value)
        return body

    def __str__(self):
        return ', '.join([
            'action: %s' % self.action,
            'priv_lvl: %s' % self.priv_lvl,
            'authen_type: %s' % self.authen_type,
            'service: %s' % self.service,
            'user_len: %d' % len(self.username),
            'port_len: 0',
            'rem_addr_len: 0',
            'data_len: %s' % len(self.data),
            'user: %s' % self.username,
            'data: %s' % self.data
        ])


class TACACSAuthenticationContinue(object):
    def __init__(self, password):
        self.password = password

    @property
    def packed(self):
        # 1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8
        #
        # +----------------+----------------+----------------+----------------+
        # |          user_msg len           |            data len             |
        # +----------------+----------------+----------------+----------------+
        # |     flags      |  user_msg ...
        # +----------------+----------------+----------------+----------------+
        # |    data ...
        # +----------------+

        # B = unsigned char
        # !H = network-order (big-endian) unsigned short
        # s = char[]
        password = six.b(self.password)
        return (
            struct.pack('!H', len(password)) +
            struct.pack('!H', 0) +
            struct.pack('B', 0) +
            struct.pack('%ds' % len(password), password)
        )

    def __str__(self):
        return ', '.join([
            'user_msg_len: %s' % len(self.password),
            'data_len: 0',
            'flags: 0',
            'user_msg: %s' % self.password
        ])


class TACACSAuthenticationReply(object):

    def __init__(self, status, flags, server_msg, data):
        self.status = status
        self.flags = flags
        self.server_msg = server_msg
        self.data = data

    @classmethod
    def unpacked(cls, raw):
        # 1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8
        #
        # +----------------+----------------+----------------+----------------+
        # |     status     |      flags     |        server_msg len           |
        # +----------------+----------------+----------------+----------------+
        # |           data len              |        server_msg ...
        # +----------------+----------------+----------------+----------------+
        # |           data ...
        # +----------------+----------------+

        # B = unsigned char
        # !H = network-order (big-endian) unsigned short
        raw = six.BytesIO(raw)
        status, flags = struct.unpack('BB', raw.read(2))
        server_msg_len, data_len = struct.unpack('!HH', raw.read(4))
        server_msg = raw.read(server_msg_len)
        data = raw.read(data_len)
        return cls(status, flags, server_msg, data)

    @property
    def valid(self):
        return self.status == TAC_PLUS_AUTHEN_STATUS_PASS

    @property
    def invalid(self):
        return self.status == TAC_PLUS_AUTHEN_STATUS_FAIL

    @property
    def error(self):
        return self.status == TAC_PLUS_AUTHEN_STATUS_ERROR

    @property
    def getpass(self):
        return self.status == TAC_PLUS_AUTHEN_STATUS_GETPASS

    @property
    def human_status(self):
        return {
            TAC_PLUS_AUTHEN_STATUS_PASS: 'PASS',
            TAC_PLUS_AUTHEN_STATUS_FAIL: 'FAIL',
            TAC_PLUS_AUTHEN_STATUS_GETPASS: 'GETPASS',
            TAC_PLUS_AUTHEN_STATUS_ERROR: 'ERROR'
        }.get(self.status, 'UNKNOWN: %s' % self.status)

    def __str__(self):
        return ', '.join([
            'status: %s' % self.human_status,
            'flags: %s' % self.flags,
            'server_msg: %s' % self.server_msg,
            'data: %s' % self.data
        ])


class TACACSAuthorizationStart(object):

    def __init__(self, username, authen_method, priv_lvl, authen_type,
                 arguments):
        self.username = username
        self.authen_method = authen_method
        self.priv_lvl = priv_lvl
        self.authen_type = authen_type
        self.service = TAC_PLUS_AUTHEN_SVC_LOGIN
        self.arguments = arguments

    @property
    def packed(self):
        #  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8
        # +----------------+----------------+----------------+----------------+
        # |  authen_method |    priv_lvl    |  authen_type   | authen_service |
        # +----------------+----------------+----------------+----------------+
        # |    user len    |    port len    |  rem_addr len  |    arg_cnt     |
        # +----------------+----------------+----------------+----------------+
        # |   arg 1 len    |   arg 2 len    |      ...       |   arg N len    |
        # +----------------+----------------+----------------+----------------+
        # |   user ...
        # +----------------+----------------+----------------+----------------+
        # |   port ...
        # +----------------+----------------+----------------+----------------+
        # |   rem_addr ...
        # +----------------+----------------+----------------+----------------+
        # |   arg 1 ...
        # +----------------+----------------+----------------+----------------+
        # |   arg 2 ...
        # +----------------+----------------+----------------+----------------+
        # |   ...
        # +----------------+----------------+----------------+----------------+
        # |   arg N ...
        # +----------------+----------------+----------------+----------------+

        # B = unsigned char
        # s = char[]
        username = six.b(self.username)
        port = rem_addr = six.b('')
        arguments = self.arguments
        body = struct.pack(
            'B' * 8,
            self.authen_method,
            self.priv_lvl,
            self.authen_type,
            self.service,
            len(username),
            len(port),
            len(rem_addr),
            len(arguments),
        )
        for value in arguments:
            body += struct.pack('B', len(value))
        for value in (username, port, rem_addr):
            body += struct.pack('%ds' % len(value), value)
        for value in arguments:
            body += struct.pack('%ds' % len(value), value)
        return body


class TACACSAuthorizationReply(object):

    def __init__(self, status, arg_cnt, server_msg, data, arguments):
        self.status = status
        self.arg_cnt = arg_cnt
        self.server_msg = server_msg
        self.data = data
        self.arguments = arguments

    @classmethod
    def unpacked(cls, raw):
        #  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8
        # +----------------+----------------+----------------+----------------+
        # |    status      |     arg_cnt    |         server_msg len          |
        # +----------------+----------------+----------------+----------------+
        # +            data len             |    arg 1 len   |    arg 2 len   |
        # +----------------+----------------+----------------+----------------+
        # |      ...       |   arg N len    |         server_msg ...
        # +----------------+----------------+----------------+----------------+
        # |   data ...
        # +----------------+----------------+----------------+----------------+
        # |   arg 1 ...
        # +----------------+----------------+----------------+----------------+
        # |   arg 2 ...
        # +----------------+----------------+----------------+----------------+
        # |   ...
        # +----------------+----------------+----------------+----------------+
        # |   arg N ...
        # +----------------+----------------+----------------+----------------+

        # B = unsigned char
        # !H = network-order (big-endian) unsigned short
        raw = six.BytesIO(raw)
        status, arg_cnt = struct.unpack('BB', raw.read(2))
        server_msg_len, data_len = struct.unpack('!HH', raw.read(4))
        args_lens = struct.unpack(
            'B' * arg_cnt, raw.read(arg_cnt)
        ) if arg_cnt else []
        server_msg = raw.read(server_msg_len)
        data = raw.read(data_len) if data_len else ''
        arguments = []
        for arg_len in args_lens:
            arg = raw.read(arg_len) if arg_len else ''
            arguments.append(arg)
        return cls(status, arg_cnt, server_msg, data, arguments)

    @property
    def valid(self):
        return self.status == TAC_PLUS_AUTHOR_STATUS_PASS_ADD

    @property
    def invalid(self):
        return self.status == TAC_PLUS_AUTHOR_STATUS_FAIL

    @property
    def error(self):
        return self.status == TAC_PLUS_AUTHOR_STATUS_ERROR

    @property
    def reply(self):
        return self.status == TAC_PLUS_AUTHOR_STATUS_PASS_REPL

    @property
    def follow(self):
        return self.status == TAC_PLUS_AUTHOR_STATUS_FOLLOW

    @property
    def human_status(self):
        return {
            TAC_PLUS_AUTHOR_STATUS_PASS_ADD: 'PASS',
            TAC_PLUS_AUTHOR_STATUS_FAIL: 'FAIL',
            TAC_PLUS_AUTHOR_STATUS_PASS_REPL: 'REPL',
            TAC_PLUS_AUTHOR_STATUS_ERROR: 'ERROR',
            TAC_PLUS_AUTHOR_STATUS_FOLLOW: 'FOLLOW',
        }.get(self.status, 'UNKNOWN: %s' % self.status)

    def __str__(self):
        return ', '.join([
            'status: %s' % self.human_status,
            'server_msg: %s' % self.server_msg,
            'args: %s' % ','.join(self.arguments)
        ])


class TACACSClient(object):
    """
    A TACACS+ authentication client.
    https://datatracker.ietf.org/doc/draft-ietf-opsawg-tacacs

    An open source TACACS+ server daemon is available at
    http://www.shrubbery.net/tac_plus/
    """

    _sock = None

    def __init__(self, host, port, secret, timeout=10, session_id=None,
                 version_max=TAC_PLUS_MAJOR_VER,
                 version_min=TAC_PLUS_MINOR_VER):
        """
        :param host:        hostname of the TACACS+ server
        :param port:        port of the TACACS+ server, generally 49
        :param secret:      the secret key used to obfuscate packet bodies; can
                            be `None` to disable packet body obfuscation
        :param session_id:  a unique 32-bit int representing the session; if
                            left empty, one will be auto-generated
        :param version_max: TACACS+ major version number, 12
        :param version_min: TACACS+ minor version number, 0 or 1
        """
        self.host = host
        self.port = port
        self.secret = secret
        self.timeout = timeout
        self.version_max = version_max
        self.version_min = version_min

        # session_id is an unsigned 32-bit int; unless it's provided, randomize
        self.session_id = session_id or random.randint(1, 2 ** 32 - 1)

    @property
    def version(self):
        return (self.version_max * 0x10) + self.version_min

    @property
    def sock(self):
        if not self._sock:
            conn = (self.host, self.port)
            self._sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self._sock.setblocking(1)
            self._sock.settimeout(self.timeout)
            self._sock.connect(conn)
        return self._sock

    @contextlib.contextmanager
    def closing(self):
        try:
            self.sock
            yield
        finally:
            if self._sock:
                self._sock.close()
                self._sock = None

    def send(self, body, req_type, seq_no=1):
        """
        Send a TACACS+ message body

        :param body:     packed bytes, i.e., `struct.pack(...)
        :param req_type: TAC_PLUS_AUTHEN /  TAC_PLUS_AUTHOR
        :param seq_no:   The sequence number of the current packet.  The
                         first packet in a session MUST have the sequence
                         number 1 and each subsequent packet will increment
                         the sequence number by one.  Thus clients only send
                         packets containing odd sequence numbers, and TACACS+
                         servers only send packets containing even sequence
                         numbers.
        :return:         TACACSPacket
        :raises:         socket.timeout, socket.error
        """
        # construct a packet
        header = TACACSHeader(
            self.version,
            req_type,
            self.session_id,
            len(body.packed),
            seq_no=seq_no
        )
        packet = TACACSPacket(header, body.packed, self.secret)

        logger.debug('\n'.join([
            body.__class__.__name__,
            'sent header <%s>' % header,
            'sent body <%s>' % body,
        ]))
        self.sock.send(bytes(packet))

        readable, _, _ = select.select([self.sock], [], [], self.timeout)
        if readable:
            # TACACS+ header packets are always 12 bytes
            header_bytes = self.sock.recv(12)
            resp_header = TACACSHeader.unpacked(header_bytes)
            # If the reply header doesn't match, it's likely a non-TACACS+ TCP
            # service answering with data we don't antipicate.  Bail out.
            if any([
                resp_header.version != header.version,
                resp_header.type != header.type,
                resp_header.session_id != header.session_id
            ]):
                logger.debug('\n'.join([
                    resp_header.__class__.__name__,
                    'recv header <%s>' % resp_header,
                    resp_header.packed
                ]))
                raise socket.error

            # read the number of bytes specified in the response header
            body_bytes = six.b('')
            remaining = resp_header.length
            while remaining > 0:
                body_bytes += self.sock.recv(remaining)
                remaining = resp_header.length - len(body_bytes)
            return TACACSPacket(
                resp_header,
                body_bytes,
                self.secret
            )
        raise socket.timeout

    def authenticate(self, username, password, priv_lvl=TAC_PLUS_PRIV_LVL_MIN,
                     authen_type=TAC_PLUS_AUTHEN_TYPE_ASCII,
                     chap_ppp_id=None, chap_challenge=None):
        """
        Authenticate to a TACACS+ server with a username and password.

        :param username:
        :param password:
        :param priv_lvl:
        :param authen_type:    TAC_PLUS_AUTHEN_TYPE_ASCII,
                               TAC_PLUS_AUTHEN_TYPE_PAP,
                               TAC_PLUS_AUTHEN_TYPE_CHAP
        :param chap_ppp_id:    PPP ID when authen_type == 'chap'
        :param chap_challenge: challenge value when authen_type == 'chap'
        :return:               TACACSAuthenticationReply
        :raises:               socket.timeout, socket.error
        """
        start_data = six.b('')
        if authen_type in (TAC_PLUS_AUTHEN_TYPE_PAP,
                           TAC_PLUS_AUTHEN_TYPE_CHAP):
            self.version_min = TAC_PLUS_MINOR_VER_ONE

            if authen_type == TAC_PLUS_AUTHEN_TYPE_PAP:
                start_data = six.b(password)

            if authen_type == TAC_PLUS_AUTHEN_TYPE_CHAP:
                if not isinstance(chap_ppp_id, six.string_types):
                    raise ValueError('chap_ppp_id must be a string')
                if not isinstance(chap_challenge, six.string_types):
                    raise ValueError('chap_challenge must be a string')
                start_data = (
                    six.b(chap_ppp_id) +
                    six.b(chap_challenge) +
                    md5(six.b(
                        chap_ppp_id + password + chap_challenge
                    )).digest()
                )
        with self.closing():
            packet = self.send(
                TACACSAuthenticationStart(username, authen_type, priv_lvl,
                                          start_data),
                TAC_PLUS_AUTHEN
            )
            reply = TACACSAuthenticationReply.unpacked(packet.body)
            logger.debug('\n'.join([
                reply.__class__.__name__,
                'recv header <%s>' % packet.header,
                'recv body <%s>' % reply
            ]))
            if authen_type == TAC_PLUS_AUTHEN_TYPE_ASCII and reply.getpass:
                packet = self.send(TACACSAuthenticationContinue(password),
                                   TAC_PLUS_AUTHEN,
                                   packet.seq_no + 1)
                reply = TACACSAuthenticationReply.unpacked(packet.body)
                logger.debug('\n'.join([
                    reply.__class__.__name__,
                    'recv header <%s>' % packet.header,
                    'recv body <%s>' % reply
                ]))
        return reply

    def authorize(self, username, arguments=[],
                  authen_type=TAC_PLUS_AUTHEN_TYPE_ASCII,
                  priv_lvl=TAC_PLUS_PRIV_LVL_MIN):
        """
        Authorize with a TACACS+ server.

        :param username:
        :param password:
        :param arguments:      The authorization arguments
        :param authen_type:    TAC_PLUS_AUTHEN_TYPE_ASCII,
                               TAC_PLUS_AUTHEN_TYPE_PAP,
                               TAC_PLUS_AUTHEN_TYPE_CHAP
        :param priv_lvl:       Minimal Required priv_lvl.
        :return:               TACACSAuthenticationReply
        :raises:               socket.timeout, socket.error
        """
        with self.closing():
            packet = self.send(
                TACACSAuthorizationStart(username,
                                         TAC_PLUS_AUTHEN_METH_TACACSPLUS,
                                         priv_lvl, authen_type, arguments),
                TAC_PLUS_AUTHOR
            )
            reply = TACACSAuthorizationReply.unpacked(packet.body)
            logger.debug('\n'.join([
                reply.__class__.__name__,
                'recv header <%s>' % packet.header,
                'recv body <%s>' % reply
            ]))

        reply_arguments = dict([
            arg.split('=', 1)
            for arg in reply.arguments or []
            if arg.find('=') > -1]
        )
        user_priv_lvl = int(reply_arguments.get(
            'priv_lvl', TAC_PLUS_PRIV_LVL_MAX))
        if user_priv_lvl < priv_lvl:
            reply.status = TAC_PLUS_AUTHOR_STATUS_FAIL
        return reply


def handle_command_line():
    parser = argparse.ArgumentParser(description='simple tacacs+ auth client')
    parser.add_argument('command', choices=['authenticate'])
    parser.add_argument('username')
    parser.add_argument('host')
    parser.add_argument('--port', '-p', type=int, default=49)
    parser.add_argument('--authen_type', choices=TAC_PLUS_AUTHEN_TYPES,
                        default='ascii')
    parser.add_argument('--timeout', type=int, default=10)
    parser.add_argument('--debug', action='store_true')

    args = parser.parse_args()
    if args.debug:
        logging.basicConfig(level=logging.DEBUG)
        logger.warn("\033[93mTACACS+ --debug will log raw packet data INCLUDING PASSWORDS; proceed at your own risk!\033[00m")  # noqa

    secret = getpass.getpass('tacacs+ secret: ')
    password = getpass.getpass('password for %s: ' % args.username)

    chap_ppp_id = six.moves.input('chap PPP ID: ') if args.authen_type == 'chap' else None  # noqa
    chap_challenge = six.moves.input('chap challenge: ') if args.authen_type == 'chap' else None  # noqa

    auth = TACACSClient(
        args.host,
        args.port,
        secret,
        timeout=args.timeout
    ).authenticate(args.username, password,
                   authen_type=TAC_PLUS_AUTHEN_TYPES[args.authen_type],
                   chap_ppp_id=chap_ppp_id,
                   chap_challenge=chap_challenge)
    if auth.valid:
        sys.exit(0)
    sys.exit(1)
